revoke delete on table "public"."ban_history" from "anon";

revoke insert on table "public"."ban_history" from "anon";

revoke references on table "public"."ban_history" from "anon";

revoke select on table "public"."ban_history" from "anon";

revoke trigger on table "public"."ban_history" from "anon";

revoke truncate on table "public"."ban_history" from "anon";

revoke update on table "public"."ban_history" from "anon";

revoke delete on table "public"."ban_history" from "authenticated";

revoke insert on table "public"."ban_history" from "authenticated";

revoke references on table "public"."ban_history" from "authenticated";

revoke select on table "public"."ban_history" from "authenticated";

revoke trigger on table "public"."ban_history" from "authenticated";

revoke truncate on table "public"."ban_history" from "authenticated";

revoke update on table "public"."ban_history" from "authenticated";

revoke delete on table "public"."ban_history" from "service_role";

revoke insert on table "public"."ban_history" from "service_role";

revoke references on table "public"."ban_history" from "service_role";

revoke select on table "public"."ban_history" from "service_role";

revoke trigger on table "public"."ban_history" from "service_role";

revoke truncate on table "public"."ban_history" from "service_role";

revoke update on table "public"."ban_history" from "service_role";

revoke delete on table "public"."event_log" from "anon";

revoke insert on table "public"."event_log" from "anon";

revoke references on table "public"."event_log" from "anon";

revoke select on table "public"."event_log" from "anon";

revoke trigger on table "public"."event_log" from "anon";

revoke truncate on table "public"."event_log" from "anon";

revoke update on table "public"."event_log" from "anon";

revoke delete on table "public"."event_log" from "authenticated";

revoke insert on table "public"."event_log" from "authenticated";

revoke references on table "public"."event_log" from "authenticated";

revoke select on table "public"."event_log" from "authenticated";

revoke trigger on table "public"."event_log" from "authenticated";

revoke truncate on table "public"."event_log" from "authenticated";

revoke update on table "public"."event_log" from "authenticated";

revoke delete on table "public"."event_log" from "service_role";

revoke insert on table "public"."event_log" from "service_role";

revoke references on table "public"."event_log" from "service_role";

revoke select on table "public"."event_log" from "service_role";

revoke trigger on table "public"."event_log" from "service_role";

revoke truncate on table "public"."event_log" from "service_role";

revoke update on table "public"."event_log" from "service_role";

revoke delete on table "public"."follows" from "anon";

revoke insert on table "public"."follows" from "anon";

revoke references on table "public"."follows" from "anon";

revoke select on table "public"."follows" from "anon";

revoke trigger on table "public"."follows" from "anon";

revoke truncate on table "public"."follows" from "anon";

revoke update on table "public"."follows" from "anon";

revoke delete on table "public"."follows" from "authenticated";

revoke insert on table "public"."follows" from "authenticated";

revoke references on table "public"."follows" from "authenticated";

revoke select on table "public"."follows" from "authenticated";

revoke trigger on table "public"."follows" from "authenticated";

revoke truncate on table "public"."follows" from "authenticated";

revoke update on table "public"."follows" from "authenticated";

revoke delete on table "public"."follows" from "service_role";

revoke insert on table "public"."follows" from "service_role";

revoke references on table "public"."follows" from "service_role";

revoke select on table "public"."follows" from "service_role";

revoke trigger on table "public"."follows" from "service_role";

revoke truncate on table "public"."follows" from "service_role";

revoke update on table "public"."follows" from "service_role";

revoke delete on table "public"."games" from "anon";

revoke insert on table "public"."games" from "anon";

revoke references on table "public"."games" from "anon";

revoke select on table "public"."games" from "anon";

revoke trigger on table "public"."games" from "anon";

revoke truncate on table "public"."games" from "anon";

revoke update on table "public"."games" from "anon";

revoke delete on table "public"."games" from "authenticated";

revoke insert on table "public"."games" from "authenticated";

revoke references on table "public"."games" from "authenticated";

revoke select on table "public"."games" from "authenticated";

revoke trigger on table "public"."games" from "authenticated";

revoke truncate on table "public"."games" from "authenticated";

revoke update on table "public"."games" from "authenticated";

revoke delete on table "public"."games" from "service_role";

revoke insert on table "public"."games" from "service_role";

revoke references on table "public"."games" from "service_role";

revoke select on table "public"."games" from "service_role";

revoke trigger on table "public"."games" from "service_role";

revoke truncate on table "public"."games" from "service_role";

revoke update on table "public"."games" from "service_role";

revoke delete on table "public"."matchmaking" from "anon";

revoke insert on table "public"."matchmaking" from "anon";

revoke references on table "public"."matchmaking" from "anon";

revoke select on table "public"."matchmaking" from "anon";

revoke trigger on table "public"."matchmaking" from "anon";

revoke truncate on table "public"."matchmaking" from "anon";

revoke update on table "public"."matchmaking" from "anon";

revoke delete on table "public"."matchmaking" from "authenticated";

revoke insert on table "public"."matchmaking" from "authenticated";

revoke references on table "public"."matchmaking" from "authenticated";

revoke select on table "public"."matchmaking" from "authenticated";

revoke trigger on table "public"."matchmaking" from "authenticated";

revoke truncate on table "public"."matchmaking" from "authenticated";

revoke update on table "public"."matchmaking" from "authenticated";

revoke delete on table "public"."matchmaking" from "service_role";

revoke insert on table "public"."matchmaking" from "service_role";

revoke references on table "public"."matchmaking" from "service_role";

revoke select on table "public"."matchmaking" from "service_role";

revoke trigger on table "public"."matchmaking" from "service_role";

revoke truncate on table "public"."matchmaking" from "service_role";

revoke update on table "public"."matchmaking" from "service_role";

revoke delete on table "public"."profiles" from "anon";

revoke insert on table "public"."profiles" from "anon";

revoke references on table "public"."profiles" from "anon";

revoke select on table "public"."profiles" from "anon";

revoke trigger on table "public"."profiles" from "anon";

revoke truncate on table "public"."profiles" from "anon";

revoke update on table "public"."profiles" from "anon";

revoke delete on table "public"."profiles" from "authenticated";

revoke insert on table "public"."profiles" from "authenticated";

revoke references on table "public"."profiles" from "authenticated";

revoke select on table "public"."profiles" from "authenticated";

revoke trigger on table "public"."profiles" from "authenticated";

revoke truncate on table "public"."profiles" from "authenticated";

revoke update on table "public"."profiles" from "authenticated";

revoke delete on table "public"."profiles" from "service_role";

revoke insert on table "public"."profiles" from "service_role";

revoke references on table "public"."profiles" from "service_role";

revoke select on table "public"."profiles" from "service_role";

revoke trigger on table "public"."profiles" from "service_role";

revoke truncate on table "public"."profiles" from "service_role";

revoke update on table "public"."profiles" from "service_role";

revoke delete on table "public"."settings" from "anon";

revoke insert on table "public"."settings" from "anon";

revoke references on table "public"."settings" from "anon";

revoke select on table "public"."settings" from "anon";

revoke trigger on table "public"."settings" from "anon";

revoke truncate on table "public"."settings" from "anon";

revoke update on table "public"."settings" from "anon";

revoke delete on table "public"."settings" from "authenticated";

revoke insert on table "public"."settings" from "authenticated";

revoke references on table "public"."settings" from "authenticated";

revoke select on table "public"."settings" from "authenticated";

revoke trigger on table "public"."settings" from "authenticated";

revoke truncate on table "public"."settings" from "authenticated";

revoke update on table "public"."settings" from "authenticated";

revoke delete on table "public"."settings" from "service_role";

revoke insert on table "public"."settings" from "service_role";

revoke references on table "public"."settings" from "service_role";

revoke select on table "public"."settings" from "service_role";

revoke trigger on table "public"."settings" from "service_role";

revoke truncate on table "public"."settings" from "service_role";

revoke update on table "public"."settings" from "service_role";

drop view if exists "public"."followed_users_status";

drop index if exists "public"."idx_profiles_last_online";

alter table "public"."matchmaking" add column "last_online" timestamp with time zone not null default now();

alter table "public"."profiles" drop column "last_online";

CREATE INDEX idx_matchmaking_last_online ON public.matchmaking USING btree (last_online);

CREATE INDEX idx_matchmaking_status_last_online ON public.matchmaking USING btree (status, last_online);

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.check_time_forfeit()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- If white player has run out of time
  IF NEW.white_time_remaining = 0 AND NEW.status = 'active' THEN
    UPDATE public.games
    SET 
      status = 'finished',
      result = 'black',
      end_reason = 'timeout'
    WHERE id = NEW.id;
    
    -- Log the event
    INSERT INTO public.event_log 
      (event_type, entity_type, entity_id, data)
    VALUES 
      ('game_timeout', 'game', NEW.id, json_build_object('player', 'white'));
  
  -- If black player has run out of time
  ELSIF NEW.black_time_remaining = 0 AND NEW.status = 'active' THEN
    UPDATE public.games
    SET 
      status = 'finished',
      result = 'white',
      end_reason = 'timeout'
    WHERE id = NEW.id;
    
    -- Log the event
    INSERT INTO public.event_log 
      (event_type, entity_type, entity_id, data)
    VALUES 
      ('game_timeout', 'game', NEW.id, json_build_object('player', 'black'));
  END IF;
  
  RETURN NULL;
END;
$function$
;

create or replace view "public"."followed_users_status" as  SELECT f.follower_id,
    f.following_id,
    f.created_at AS followed_at,
    u.username,
        CASE
            WHEN (g.id IS NOT NULL) THEN jsonb_build_object('game_id', g.id, 'status', g.status, 'white_player_id', g.white_player_id, 'black_player_id', g.black_player_id, 'created_at', g.created_at, 'current_fen', g.current_fen)
            ELSE NULL::jsonb
        END AS active_game
   FROM ((follows f
     JOIN profiles u ON ((u.id = f.following_id)))
     LEFT JOIN LATERAL ( SELECT games.id,
            games.white_player_id,
            games.black_player_id,
            games.status,
            games.turn,
            games.current_fen,
            games.pgn,
            games.result,
            games.draw_offered_by,
            games.rematch_offered_by,
            games.end_reason,
            games.last_move,
            games.banning_player,
            games.parent_game_id,
            games.created_at,
            games.updated_at,
            games.white_time_remaining,
            games.black_time_remaining,
            games.time_control
           FROM games
          WHERE ((games.status = 'active'::game_status) AND ((games.white_player_id = f.following_id) OR (games.black_player_id = f.following_id)))
          ORDER BY games.created_at DESC
         LIMIT 1) g ON (true));


CREATE OR REPLACE FUNCTION public.get_default_initial_time()
 RETURNS bigint
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
BEGIN
  RETURN (public.get_default_time_control()->>'initial_time')::BIGINT;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_default_time_control()
 RETURNS jsonb
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
DECLARE
  settings_value JSONB;
BEGIN
  -- Get time control settings from the settings table
  SELECT value INTO settings_value
  FROM public.settings
  WHERE key = 'default_time_control';
  
  -- Return default value if not found in settings table
  IF settings_value IS NULL THEN
    RETURN '{"initial_time": 600000, "increment": 0}'::jsonb;
  END IF;
  
  RETURN settings_value;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_follow_stats(user_id uuid)
 RETURNS jsonb
 LANGUAGE sql
 STABLE
AS $function$
    SELECT jsonb_build_object(
        'followers_count', (SELECT COUNT(*) FROM public.follows WHERE following_id = user_id),
        'following_count', (SELECT COUNT(*) FROM public.follows WHERE follower_id = user_id)
    );
$function$
;

CREATE OR REPLACE FUNCTION public.initialize_time_control()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- If time control is not set, initialize with default values
  IF NEW.time_control IS NULL THEN
    NEW.time_control := public.get_default_time_control();
    NEW.white_time_remaining := public.get_default_initial_time();
    NEW.black_time_remaining := public.get_default_initial_time();
  -- If time control is set, but time remaining is not initialized
  ELSIF NEW.white_time_remaining IS NULL OR NEW.black_time_remaining IS NULL THEN
    -- Set initial time for both players
    NEW.white_time_remaining := (NEW.time_control->>'initial_time')::BIGINT;
    NEW.black_time_remaining := (NEW.time_control->>'initial_time')::BIGINT;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_following(follower uuid, following uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
    SELECT EXISTS(
        SELECT 1 FROM public.follows 
        WHERE follower_id = follower AND following_id = following
    );
$function$
;

CREATE OR REPLACE FUNCTION public.sync_time_control_settings()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- If the default time control setting was updated, log the event
  IF NEW.key = 'default_time_control' AND 
     (OLD.value IS NULL OR OLD.value IS DISTINCT FROM NEW.value) THEN
    
    -- Log the change
    INSERT INTO public.event_log 
      (event_type, entity_type, entity_id, data)
    VALUES 
      ('settings_updated', 'time_control', 'default', json_build_object(
        'old_value', OLD.value,
        'new_value', NEW.value
      ));
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_time_remaining()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  time_used BIGINT;
  player_time_column TEXT;
  current_player_color TEXT;
BEGIN
  -- If time control is not set, or status is not active, do nothing
  IF NEW.time_control IS NULL OR NEW.status <> 'active' THEN
    RETURN NEW;
  END IF;
  
  -- Handle time update based on turn change or banning player change
  IF OLD.turn <> NEW.turn OR OLD.banning_player IS DISTINCT FROM NEW.banning_player THEN
    -- Calculate time used (time between moves)
    time_used := EXTRACT(EPOCH FROM (NEW.updated_at - OLD.updated_at)) * 1000; -- milliseconds
    
    -- Determine which player was active (whose time was running)
    -- If there was a banning player, their time was running
    IF OLD.banning_player IS NOT NULL THEN
      IF OLD.banning_player = 'white' THEN
        player_time_column := 'white_time_remaining';
      ELSE
        player_time_column := 'black_time_remaining';
      END IF;
    ELSE
      -- Otherwise, use the player whose turn it was
      IF OLD.turn = 'white' THEN
        player_time_column := 'white_time_remaining';
      ELSE
        player_time_column := 'black_time_remaining';
      END IF;
    END IF;
    
    -- Update time remaining for the player who was active
    IF player_time_column = 'white_time_remaining' THEN
      -- Update white player time (subtract time used)
      NEW.white_time_remaining := GREATEST(0, COALESCE(OLD.white_time_remaining, (NEW.time_control->>'initial_time')::BIGINT) - time_used);
    ELSE
      -- Update black player time (subtract time used)
      NEW.black_time_remaining := GREATEST(0, COALESCE(OLD.black_time_remaining, (NEW.time_control->>'initial_time')::BIGINT) - time_used);
    END IF;
  END IF;
  
  -- No longer check for timeout here - this will be done in a separate AFTER trigger
  -- PERFORM public.check_time_forfeit(NEW);
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_timestamp()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;


