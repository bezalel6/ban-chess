# Development Standards - Type Safety & Database Consistency

## Critical Type Information

### Game IDs
- **Type**: `text` (8 alphanumeric characters)
- **Format**: `[A-Za-z0-9]{8}` (e.g., "Hqz08ubN")
- **Generated by**: `generateShortId()` in edge functions
- **NEVER**: Use UUID for game IDs

### Player IDs  
- **Type**: `uuid`
- **Source**: `auth.users.id`
- **Format**: Standard UUID v4 (e.g., "d50b16ed-27cb-4f94-a0db-4942d0b0f60e")

### Player Colors
- **Type**: `player_color` enum
- **Values**: `'white'` or `'black'`
- **NEVER**: Use other string values

## Preventing Type Mismatches

### 1. ALWAYS Create Text Overloads
When creating a database function that accepts game_id or player_id:

```sql
-- Primary function with correct types
CREATE FUNCTION handle_something(
  game_id text,  -- NOT uuid!
  player_id uuid
) RETURNS jsonb AS $$ ... $$;

-- Text overload for edge functions
CREATE FUNCTION handle_something(
  game_id text,
  player_id text  -- Accepts text, converts internally
) RETURNS jsonb AS $$
BEGIN
  RETURN handle_something(game_id, player_id::uuid);
END;
$$;
```

### 2. Edge Function Best Practices

```typescript
// GOOD - Pass parameters as-is
const { data, error } = await supabase.rpc('handle_something', {
  game_id: gameId,  // Pass as string
  player_id: playerId  // Pass as string
});

// BAD - Don't try to cast types
const { data, error } = await supabase.rpc('handle_something', {
  game_id: gameId as any,  // Don't do this!
  player_id: new UUID(playerId)  // Don't do this!
});
```

### 3. TypeScript Type Definitions

```typescript
// src/types/database.ts
interface Game {
  id: string;  // NOT string | UUID
  white_player_id: string;  // UUID as string
  black_player_id: string;  // UUID as string
  // ...
}

interface GameFunction {
  handle_player_reconnect: {
    Args: {
      game_id: string;  // Text game ID
      player_id: string;  // UUID as string
    };
    Returns: {
      success: boolean;
      error?: string;
    };
  };
}
```

### 4. Database Migration Standards

```sql
-- ALWAYS include these in game-related migrations:

-- 1. Drop existing overloads to prevent conflicts
DROP FUNCTION IF EXISTS function_name(uuid, uuid);
DROP FUNCTION IF EXISTS function_name(text, uuid);
DROP FUNCTION IF EXISTS function_name(text, text);

-- 2. Create main function with correct types
CREATE OR REPLACE FUNCTION function_name(
  game_id text,  -- Games use text IDs
  player_id uuid
) ...

-- 3. Create text overload for edge functions
CREATE OR REPLACE FUNCTION function_name(
  game_id text,
  player_id text
) ...

-- 4. Grant permissions to all versions
GRANT EXECUTE ON FUNCTION function_name(text, uuid) TO authenticated, service_role;
GRANT EXECUTE ON FUNCTION function_name(text, text) TO authenticated, service_role;
```

### 5. Testing Checklist

Before deploying any database function:

- [ ] Test with actual game ID format (8-char string)
- [ ] Test with actual player ID format (UUID)
- [ ] Test text overload from edge function
- [ ] Verify no type casting errors in logs
- [ ] Check function_type_check view for warnings

### 6. Debugging Type Issues

```sql
-- Check what types a function expects
SELECT 
  proname as function_name,
  pg_get_function_identity_arguments(oid) as arguments
FROM pg_proc 
WHERE proname = 'your_function_name';

-- Check for missing text overloads
SELECT * FROM function_type_check WHERE status != 'OK';

-- Verify game ID format
SELECT id, length(id), id ~ '^[A-Za-z0-9]{8}$' as valid_format
FROM games 
LIMIT 10;
```

## Common Pitfalls to Avoid

### ❌ DON'T
1. Assume game IDs are UUIDs
2. Try to convert game IDs to UUIDs
3. Create functions without text overloads
4. Use `.single()` without handling no-row cases
5. Cast types in TypeScript/JavaScript

### ✅ DO
1. Always use text for game IDs
2. Create defensive text overloads
3. Validate input formats
4. Handle edge cases (no rows, duplicates)
5. Test with real data formats

## Emergency Fixes

If you encounter type mismatch errors:

1. **Identify the function**:
   ```sql
   SELECT * FROM function_type_check WHERE status != 'OK';
   ```

2. **Create text overload**:
   ```sql
   CREATE OR REPLACE FUNCTION function_name(
     game_id text,
     player_id text
   ) RETURNS jsonb AS $$
   BEGIN
     RETURN function_name(game_id, player_id::uuid);
   EXCEPTION WHEN OTHERS THEN
     RETURN jsonb_build_object('error', SQLERRM);
   END;
   $$ LANGUAGE plpgsql SECURITY DEFINER;
   ```

3. **Apply to both local and remote**:
   ```bash
   # Local
   psql $DATABASE_URL -f fix.sql
   
   # Remote - use Supabase dashboard
   ```

## Type Safety Monitoring

Run these checks regularly:

```sql
-- Check for type mismatches
SELECT * FROM function_type_check WHERE status != 'OK';

-- Check for invalid game IDs
SELECT COUNT(*) as invalid_games 
FROM games 
WHERE NOT (id ~ '^[A-Za-z0-9]{8}$');

-- Check for missing text overloads
SELECT DISTINCT proname 
FROM pg_proc 
WHERE proname LIKE 'handle_%'
  AND NOT EXISTS (
    SELECT 1 FROM pg_proc p2 
    WHERE p2.proname = proname 
    AND pg_get_function_identity_arguments(p2.oid) LIKE '%text%text%'
  );
```

## Remember

**The root cause of most type errors**:
- Games use 8-character text IDs, not UUIDs
- Edge functions pass everything as text/JSON
- Database functions expect specific types
- **Solution**: Always create text overloads!